# å‰ç«¯æœç´¢è¿‡ç¨‹å¯è§†åŒ– - å…·ä½“ä»»åŠ¡æ¨¡å—åˆ†è§£

åŸºäºå½“å‰é¡¹ç›®ä»£ç ç»“æ„ï¼Œå°†å®æ–½è®¡åˆ’åˆ†è§£ä¸ºå…·ä½“çš„å¯æ‰§è¡Œä»»åŠ¡æ¨¡å—ã€‚

---

## ğŸ“‹ ä»»åŠ¡æ¨¡å—æ€»è§ˆ

### **æ¨¡å—1: æ•°æ®ç»“æ„å®šä¹‰** (ä¼˜å…ˆçº§: æœ€é«˜)
- åˆ›å»ºTypeScriptæ¥å£å®šä¹‰
- åŸºäºç°æœ‰ä»£ç ç»“æ„è®¾è®¡traceæ ¼å¼

### **æ¨¡å—2: SearchServiceå¢å¼º** (ä¼˜å…ˆçº§: æœ€é«˜)
- ä¿®æ”¹ç°æœ‰SearchServiceæ·»åŠ traceæ”¶é›†
- å®ç°è°ƒè¯•æ¨¡å¼å¼€å…³

### **æ¨¡å—3: APIç«¯ç‚¹æ‰©å±•** (ä¼˜å…ˆçº§: é«˜)
- åœ¨ç°æœ‰routes.pyä¸­æ·»åŠ è°ƒè¯•æ¥å£
- å®ç°WebSocketæ”¯æŒ

### **æ¨¡å—4: å‰ç«¯ç•Œé¢ç»„ä»¶** (ä¼˜å…ˆçº§: é«˜)
- åŸºäºç°æœ‰frontend/ä¿®æ”¹ç•Œé¢
- åˆ›å»ºæœç´¢è¿‡ç¨‹å¯è§†åŒ–ç»„ä»¶

### **æ¨¡å—5: å®æ—¶æ•°æ®æ¨é€** (ä¼˜å…ˆçº§: ä¸­)
- å®ç°WebSocketè¿æ¥
- å‰åç«¯æ•°æ®åŒæ­¥

---

## ğŸ”§ ä»»åŠ¡æ¨¡å—è¯¦ç»†åˆ†è§£

### **æ¨¡å—1: æ•°æ®ç»“æ„å®šä¹‰**

#### ä»»åŠ¡1.1: åˆ›å»ºTypeScriptç±»å‹å®šä¹‰æ–‡ä»¶
**æ–‡ä»¶**: `src/types/debug_interfaces.py`

```python
# åˆ›å»ºPythonæ•°æ®æ¨¡å‹
from typing import Dict, List, Optional, Any, Union
from pydantic import BaseModel
from datetime import datetime

class ModuleTrace(BaseModel):
    """æ¨¡å—æ‰§è¡Œtraceæ•°æ®"""
    module_name: str
    stage: str
    input_data: Any
    output_data: Any
    processing_time_ms: float
    success: bool
    confidence_score: Optional[float] = None
    debug_info: Dict[str, Any]
    metadata: Dict[str, Any]
    timestamp: datetime

class SearchPipelineTrace(BaseModel):
    """æœç´¢ç®¡é“å®Œæ•´trace"""
    request_id: str
    user_query: str
    total_duration_ms: float

    # å„é˜¶æ®µtrace
    classification: Optional[ModuleTrace] = None
    extraction: Optional[ModuleTrace] = None
    routing: Optional[ModuleTrace] = None
    searches: Dict[str, ModuleTrace] = {}
    fusion: Optional[ModuleTrace] = None

    # ç»Ÿè®¡ä¿¡æ¯
    summary: Dict[str, Any]
```

**é¢„è®¡è€—æ—¶**: 0.5å¤©

#### ä»»åŠ¡1.2: åˆ›å»ºå‰ç«¯TypeScriptæ¥å£
**æ–‡ä»¶**: `frontend/types/search-debug.ts`

```typescript
// å¯¹åº”Pythonæ¨¡å‹çš„TypeScriptæ¥å£
export interface ModuleTrace {
  module_name: string;
  stage: string;
  input_data: any;
  output_data: any;
  processing_time_ms: number;
  success: boolean;
  confidence_score?: number;
  debug_info: Record<string, any>;
  metadata: Record<string, any>;
  timestamp: string;
}

export interface SearchPipelineTrace {
  request_id: string;
  user_query: string;
  total_duration_ms: number;
  classification?: ModuleTrace;
  extraction?: ModuleTrace;
  routing?: ModuleTrace;
  searches: Record<string, ModuleTrace>;
  fusion?: ModuleTrace;
  summary: Record<string, any>;
}
```

**é¢„è®¡è€—æ—¶**: 0.5å¤©

---

### **æ¨¡å—2: SearchServiceå¢å¼º**

#### ä»»åŠ¡2.1: ä¿®æ”¹ç°æœ‰SearchServiceç±»
**æ–‡ä»¶**: `src/services/search_service.py`

```python
# åœ¨ç°æœ‰SearchServiceä¸­æ·»åŠ traceæ”¶é›†åŠŸèƒ½

class SearchService:
    def __init__(self, repository: ILegalDocumentRepository, debug_mode: bool = False):
        self.repository = repository
        self.debug_mode = debug_mode
        self.current_trace: Optional[SearchPipelineTrace] = None

    async def search_documents_kg_enhanced_with_trace(self, query_text: str,
                                                    articles_count: int = 5,
                                                    cases_count: int = 5) -> Tuple[Dict[str, Any], Optional[ModuleTrace]]:
        """ç°æœ‰çŸ¥è¯†å›¾è°±æœç´¢æ–¹æ³• + traceæ”¶é›†"""
        start_time = time.time()

        try:
            # è°ƒç”¨ç°æœ‰æ–¹æ³•
            result = await self.search_documents_kg_enhanced(query_text, articles_count, cases_count)

            # æ”¶é›†traceä¿¡æ¯
            if self.debug_mode:
                trace = ModuleTrace(
                    module_name="knowledge_graph_search",
                    stage="search_execution",
                    input_data={
                        "query": query_text,
                        "articles_count": articles_count,
                        "cases_count": cases_count
                    },
                    output_data=result,
                    processing_time_ms=(time.time() - start_time) * 1000,
                    success=result.get('success', False),
                    debug_info={
                        "method_used": "kg_enhanced",
                        "fallback_triggered": not result.get('search_context', {}).get('kg_enhanced', False),
                        "knowledge_expansion": result.get('search_context', {}).get('knowledge_expansion', {})
                    },
                    metadata={
                        "timestamp": datetime.now().isoformat(),
                        "module_version": "1.0.0"
                    }
                )
                return result, trace

            return result, None

        except Exception as e:
            if self.debug_mode:
                trace = ModuleTrace(
                    module_name="knowledge_graph_search",
                    stage="search_execution",
                    input_data={"query": query_text},
                    output_data={},
                    processing_time_ms=(time.time() - start_time) * 1000,
                    success=False,
                    debug_info={
                        "error_message": str(e),
                        "fallback_triggered": True
                    },
                    metadata={"timestamp": datetime.now().isoformat()}
                )
                return self._create_error_response(str(e)), trace

            raise e
```

**é¢„è®¡è€—æ—¶**: 1å¤©

#### ä»»åŠ¡2.2: ä¸ºå…¶ä»–æœç´¢æ–¹æ³•æ·»åŠ trace
**æ–‡ä»¶**: ç»§ç»­ä¿®æ”¹ `src/services/search_service.py`

```python
# ä¸ºæ¯ä¸ªç°æœ‰æœç´¢æ–¹æ³•æ·»åŠ traceç‰ˆæœ¬
async def search_documents_mixed_with_trace(self, ...):
    """åŸºç¡€è¯­ä¹‰æœç´¢ + trace"""
    # ç±»ä¼¼å®ç°...

async def search_documents_hybrid_with_trace(self, ...):
    """BM25æ··åˆæœç´¢ + trace"""
    # ç±»ä¼¼å®ç°...

async def search_documents_enhanced_with_trace(self, ...):
    """LLMå¢å¼ºæœç´¢ + trace"""
    # ç±»ä¼¼å®ç°...
```

**é¢„è®¡è€—æ—¶**: 1å¤©

#### ä»»åŠ¡2.3: åˆ›å»ºç»Ÿä¸€çš„è°ƒè¯•æœç´¢æ–¹æ³•
**æ–‡ä»¶**: ç»§ç»­ä¿®æ”¹ `src/services/search_service.py`

```python
async def search_with_full_pipeline_trace(self, query_text: str,
                                        articles_count: int = 5,
                                        cases_count: int = 5) -> SearchPipelineTrace:
    """å®Œæ•´çš„5é˜¶æ®µæœç´¢ç®¡é“ + å®Œæ•´trace"""
    request_id = str(uuid.uuid4())
    start_time = time.time()

    pipeline_trace = SearchPipelineTrace(
        request_id=request_id,
        user_query=query_text,
        total_duration_ms=0,
        searches={},
        summary={}
    )

    # é˜¶æ®µ1: LLMåˆ†ç±» (æ¨¡æ‹Ÿå®ç°)
    classification_result, classification_trace = await self._classify_query_with_trace(query_text)
    pipeline_trace.classification = classification_trace

    if classification_result.get('is_criminal_law', True):  # åˆ‘æ³•ç›¸å…³
        # é˜¶æ®µ2: ç»“æ„åŒ–æå–
        extraction_result, extraction_trace = await self._extract_structured_info_with_trace(query_text)
        pipeline_trace.extraction = extraction_trace

        # é˜¶æ®µ3: æ™ºèƒ½è·¯ç”±
        routing_result, routing_trace = await self._intelligent_routing_with_trace(extraction_result)
        pipeline_trace.routing = routing_trace

        # é˜¶æ®µ4: å¹¶è¡Œæœç´¢
        search_results = {}
        if 'kg_search' in routing_result.get('selected_paths', []):
            result, trace = await self.search_documents_kg_enhanced_with_trace(query_text, articles_count, cases_count)
            search_results['knowledge_graph'] = result
            pipeline_trace.searches['knowledge_graph'] = trace

        if 'enhanced_search' in routing_result.get('selected_paths', []):
            result, trace = await self.search_documents_enhanced_with_trace(query_text, articles_count, cases_count)
            search_results['llm_enhanced'] = result
            pipeline_trace.searches['llm_enhanced'] = trace

        # é˜¶æ®µ5: èåˆ
        fusion_result, fusion_trace = await self._fuse_results_with_trace(search_results)
        pipeline_trace.fusion = fusion_trace

    else:  # éåˆ‘æ³•é—®é¢˜
        # ç›´æ¥AIå›ç­”æ¨¡å¼
        ai_result, ai_trace = await self._general_ai_response_with_trace(query_text)
        pipeline_trace.searches['general_ai'] = ai_trace

    # å®Œæˆæ€»ä½“ç»Ÿè®¡
    pipeline_trace.total_duration_ms = (time.time() - start_time) * 1000
    pipeline_trace.summary = self._generate_pipeline_summary(pipeline_trace)

    return pipeline_trace
```

**é¢„è®¡è€—æ—¶**: 1.5å¤©

---

### **æ¨¡å—3: APIç«¯ç‚¹æ‰©å±•**

#### ä»»åŠ¡3.1: ä¿®æ”¹ç°æœ‰routes.pyæ·»åŠ è°ƒè¯•æ¥å£
**æ–‡ä»¶**: `src/api/routes.py`

```python
# åœ¨ç°æœ‰routes.pyä¸­æ·»åŠ è°ƒè¯•ç›¸å…³çš„è·¯ç”±

@router.post("/search/debug")
async def debug_search(request: SearchRequest, search_service: SearchService = Depends(get_search_service)):
    """è°ƒè¯•æ¨¡å¼æœç´¢ - è¿”å›å®Œæ•´trace"""
    try:
        # ä¸´æ—¶å¯ç”¨è°ƒè¯•æ¨¡å¼
        search_service.debug_mode = True

        pipeline_trace = await search_service.search_with_full_pipeline_trace(
            request.query,
            request.articles_count,
            request.cases_count
        )

        return {
            "success": True,
            "trace": pipeline_trace.dict(),
            "request_id": pipeline_trace.request_id
        }

    except Exception as e:
        logger.error(f"Debug search failed: {e}")
        return {"success": False, "error": str(e)}


@router.get("/debug/trace/{request_id}")
async def get_search_trace(request_id: str):
    """è·å–ç‰¹å®šæœç´¢çš„traceè®°å½•"""
    # ä»Redisæˆ–æ•°æ®åº“è·å–å­˜å‚¨çš„trace
    pass

@router.get("/debug/modules/status")
async def get_modules_status():
    """è·å–æ‰€æœ‰æœç´¢æ¨¡å—çŠ¶æ€"""
    return {
        "modules": {
            "knowledge_graph": {"status": "error", "reason": "æœªåˆå§‹åŒ–"},
            "llm_enhanced": {"status": "error", "reason": "ä»£ç bug"},
            "bm25_hybrid": {"status": "warning", "reason": "ä¾èµ–BM25ç´¢å¼•"},
            "basic_semantic": {"status": "ok", "reason": "å®Œå…¨å¯ç”¨"}
        }
    }
```

**é¢„è®¡è€—æ—¶**: 1å¤©

#### ä»»åŠ¡3.2: å®ç°WebSocketæ”¯æŒ
**æ–‡ä»¶**: `src/api/websocket.py` (æ–°å»ºæ–‡ä»¶)

```python
# åˆ›å»ºWebSocketæ”¯æŒå®æ—¶æ•°æ®æ¨é€

from fastapi import WebSocket
import json
import asyncio

class DebugWebSocketManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast_trace_update(self, trace_data: dict):
        """å¹¿æ’­traceæ›´æ–°åˆ°æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯"""
        for connection in self.active_connections:
            await connection.send_text(json.dumps(trace_data))

manager = DebugWebSocketManager()

@router.websocket("/ws/debug")
async def debug_websocket(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            # ä¿æŒè¿æ¥
            await websocket.receive_text()
    except:
        manager.disconnect(websocket)
```

**é¢„è®¡è€—æ—¶**: 0.5å¤©

---

### **æ¨¡å—4: å‰ç«¯ç•Œé¢ç»„ä»¶**

#### ä»»åŠ¡4.1: ä¿®æ”¹ç°æœ‰å‰ç«¯ç•Œé¢æ·»åŠ è°ƒè¯•é¢æ¿
**æ–‡ä»¶**: `frontend/index.html`

```html
<!-- åœ¨ç°æœ‰ç•Œé¢åŸºç¡€ä¸Šæ·»åŠ è°ƒè¯•é¢æ¿ -->

<!-- æ·»åŠ è°ƒè¯•æ¨¡å¼åˆ‡æ¢ -->
<div class="debug-controls" style="margin-bottom: 20px;">
    <label>
        <input type="checkbox" id="debugMode" onchange="toggleDebugMode()">
        è°ƒè¯•æ¨¡å¼ - æ˜¾ç¤ºæœç´¢è¿‡ç¨‹
    </label>
</div>

<!-- æœç´¢è¿›åº¦å±•ç¤ºé¢æ¿ -->
<div id="searchProgress" class="search-progress" style="display: none;">
    <h3>æœç´¢è¿‡ç¨‹å®æ—¶å±•ç¤º</h3>

    <div class="pipeline-stages">
        <div class="stage" id="stage-classification">
            <div class="stage-icon">ğŸ¤–</div>
            <div class="stage-name">é—®é¢˜åˆ†ç±»</div>
            <div class="stage-status">ç­‰å¾…ä¸­...</div>
            <div class="stage-time"></div>
        </div>

        <div class="stage" id="stage-extraction">
            <div class="stage-icon">ğŸ”</div>
            <div class="stage-name">ä¿¡æ¯æå–</div>
            <div class="stage-status">ç­‰å¾…ä¸­...</div>
            <div class="stage-time"></div>
        </div>

        <div class="stage" id="stage-search">
            <div class="stage-icon">ğŸ“š</div>
            <div class="stage-name">æ™ºèƒ½æœç´¢</div>
            <div class="stage-status">ç­‰å¾…ä¸­...</div>
            <div class="stage-time"></div>
        </div>

        <div class="stage" id="stage-fusion">
            <div class="stage-icon">âš¡</div>
            <div class="stage-name">ç»“æœèåˆ</div>
            <div class="stage-status">ç­‰å¾…ä¸­...</div>
            <div class="stage-time"></div>
        </div>
    </div>
</div>

<!-- è¯¦ç»†æ•°æ®æŸ¥çœ‹é¢æ¿ -->
<div id="debugDetails" class="debug-details" style="display: none;">
    <h3>è¯¦ç»†è°ƒè¯•ä¿¡æ¯</h3>
    <div class="trace-data">
        <pre id="traceJson"></pre>
    </div>
</div>
```

**é¢„è®¡è€—æ—¶**: 1å¤©

#### ä»»åŠ¡4.2: æ·»åŠ JavaScriptå¤„ç†é€»è¾‘
**æ–‡ä»¶**: `frontend/js/debug.js` (æ–°å»ºæ–‡ä»¶)

```javascript
// è°ƒè¯•æ¨¡å¼çš„JavaScriptå¤„ç†é€»è¾‘

class SearchDebugger {
    constructor() {
        this.debugMode = false;
        this.currentTrace = null;
        this.ws = null;
    }

    toggleDebugMode() {
        this.debugMode = document.getElementById('debugMode').checked;

        if (this.debugMode) {
            document.getElementById('searchProgress').style.display = 'block';
            document.getElementById('debugDetails').style.display = 'block';
            this.connectWebSocket();
        } else {
            document.getElementById('searchProgress').style.display = 'none';
            document.getElementById('debugDetails').style.display = 'none';
            if (this.ws) this.ws.close();
        }
    }

    connectWebSocket() {
        this.ws = new WebSocket('ws://localhost:5006/ws/debug');

        this.ws.onmessage = (event) => {
            const traceData = JSON.parse(event.data);
            this.updateProgress(traceData);
        };
    }

    async performDebugSearch(query) {
        if (!this.debugMode) {
            return await this.performNormalSearch(query);
        }

        this.resetProgress();

        const response = await fetch('/api/search/debug', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                query: query,
                articles_count: 5,
                cases_count: 5
            })
        });

        const result = await response.json();
        if (result.success) {
            this.currentTrace = result.trace;
            this.displayTraceData(result.trace);
            this.updateFinalProgress(result.trace);
        }

        return result;
    }

    updateProgress(traceData) {
        if (traceData.module_name) {
            const stageId = this.mapModuleToStage(traceData.module_name);
            const stage = document.getElementById(stageId);

            if (stage) {
                stage.querySelector('.stage-status').textContent =
                    traceData.success ? 'å®Œæˆ' : 'å¤±è´¥';
                stage.querySelector('.stage-time').textContent =
                    `${traceData.processing_time_ms.toFixed(0)}ms`;
                stage.className = 'stage ' + (traceData.success ? 'success' : 'error');
            }
        }
    }

    mapModuleToStage(moduleName) {
        const mapping = {
            'llm_classifier': 'stage-classification',
            'structured_extractor': 'stage-extraction',
            'knowledge_graph_search': 'stage-search',
            'llm_enhanced_search': 'stage-search',
            'result_fusion': 'stage-fusion'
        };
        return mapping[moduleName] || 'stage-search';
    }

    displayTraceData(trace) {
        document.getElementById('traceJson').textContent =
            JSON.stringify(trace, null, 2);
    }
}

// å…¨å±€å®ä¾‹
const debugger = new SearchDebugger();

// ä¿®æ”¹ç°æœ‰çš„æœç´¢å‡½æ•°
async function performSearch() {
    const query = document.getElementById('searchInput').value;
    if (!query.trim()) return;

    const result = await debugger.performDebugSearch(query);

    // æ˜¾ç¤ºæœç´¢ç»“æœ
    displaySearchResults(result);
}

function toggleDebugMode() {
    debugger.toggleDebugMode();
}
```

**é¢„è®¡è€—æ—¶**: 1.5å¤©

---

### **æ¨¡å—5: å®æ—¶æ•°æ®æ¨é€**

#### ä»»åŠ¡5.1: é›†æˆWebSocketåˆ°æœç´¢æµç¨‹
**æ–‡ä»¶**: ä¿®æ”¹ `src/services/search_service.py`

```python
# åœ¨æœç´¢è¿‡ç¨‹ä¸­æ¨é€å®æ—¶æ›´æ–°

class SearchService:
    def __init__(self, repository, debug_mode=False, websocket_manager=None):
        self.repository = repository
        self.debug_mode = debug_mode
        self.websocket_manager = websocket_manager

    async def _notify_trace_update(self, trace: ModuleTrace):
        """æ¨é€traceæ›´æ–°åˆ°å‰ç«¯"""
        if self.websocket_manager and self.debug_mode:
            await self.websocket_manager.broadcast_trace_update(trace.dict())

    async def search_documents_kg_enhanced_with_trace(self, ...):
        # ç°æœ‰é€»è¾‘...

        # æ·»åŠ å®æ—¶æ¨é€
        if trace:
            await self._notify_trace_update(trace)

        return result, trace
```

**é¢„è®¡è€—æ—¶**: 0.5å¤©

#### ä»»åŠ¡5.2: å‰ç«¯WebSocketè¿æ¥ä¼˜åŒ–
**æ–‡ä»¶**: ä¿®æ”¹ `frontend/js/debug.js`

```javascript
// ä¼˜åŒ–WebSocketè¿æ¥å’Œé”™è¯¯å¤„ç†

connectWebSocket() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        return;
    }

    this.ws = new WebSocket('ws://localhost:5006/ws/debug');

    this.ws.onopen = () => {
        console.log('è°ƒè¯•WebSocketè¿æ¥å·²å»ºç«‹');
    };

    this.ws.onmessage = (event) => {
        try {
            const traceData = JSON.parse(event.data);
            this.updateProgress(traceData);
        } catch (e) {
            console.error('è§£ætraceæ•°æ®å¤±è´¥:', e);
        }
    };

    this.ws.onerror = (error) => {
        console.error('WebSocketé”™è¯¯:', error);
    };

    this.ws.onclose = () => {
        console.log('WebSocketè¿æ¥å·²å…³é—­');
        // å¦‚æœæ˜¯æ„å¤–å…³é—­ï¼Œå°è¯•é‡è¿
        if (this.debugMode) {
            setTimeout(() => this.connectWebSocket(), 3000);
        }
    };
}
```

**é¢„è®¡è€—æ—¶**: 0.5å¤©

---

## ğŸ“… ä»»åŠ¡æ‰§è¡Œé¡ºåº

### **ç¬¬ä¸€å‘¨**
1. **ä»»åŠ¡1.1 + 1.2**: æ•°æ®ç»“æ„å®šä¹‰ (1å¤©)
2. **ä»»åŠ¡2.1**: SearchServiceåŸºç¡€å¢å¼º (1å¤©)
3. **ä»»åŠ¡2.2**: å…¶ä»–æœç´¢æ–¹æ³•trace (1å¤©)
4. **ä»»åŠ¡2.3**: ç»Ÿä¸€è°ƒè¯•æœç´¢æ–¹æ³• (1.5å¤©)
5. **ä»»åŠ¡3.1**: APIç«¯ç‚¹æ‰©å±• (0.5å¤©)

### **ç¬¬äºŒå‘¨**
6. **ä»»åŠ¡3.2**: WebSocketæ”¯æŒ (0.5å¤©)
7. **ä»»åŠ¡4.1**: å‰ç«¯ç•Œé¢ç»„ä»¶ (1å¤©)
8. **ä»»åŠ¡4.2**: JavaScriptå¤„ç†é€»è¾‘ (1.5å¤©)
9. **ä»»åŠ¡5.1**: WebSocketé›†æˆ (0.5å¤©)
10. **ä»»åŠ¡5.2**: å‰ç«¯è¿æ¥ä¼˜åŒ– (0.5å¤©)

**æ€»è®¡**: 9ä¸ªå·¥ä½œæ—¥

---

## ğŸ¯ æ¯ä¸ªä»»åŠ¡çš„éªŒæ”¶æ ‡å‡†

### **æ•°æ®ç»“æ„å®šä¹‰**
- [ ] Python ModuleTraceç±»å®šä¹‰å®Œæ•´
- [ ] TypeScriptæ¥å£ä¸Pythonæ¨¡å‹ä¸€è‡´
- [ ] æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½æœ‰æ˜ç¡®ç±»å‹

### **SearchServiceå¢å¼º**
- [ ] ç°æœ‰æœç´¢æ–¹æ³•ä¸å—å½±å“
- [ ] è°ƒè¯•æ¨¡å¼å¯æ­£å¸¸å¼€å¯/å…³é—­
- [ ] traceæ•°æ®æ ¼å¼æ­£ç¡®ä¸”å®Œæ•´

### **APIç«¯ç‚¹æ‰©å±•**
- [ ] `/api/search/debug`æ¥å£æ­£å¸¸å·¥ä½œ
- [ ] WebSocketè¿æ¥ç¨³å®š
- [ ] é”™è¯¯å¤„ç†å®Œå–„

### **å‰ç«¯ç•Œé¢ç»„ä»¶**
- [ ] è°ƒè¯•é¢æ¿å¯æ­£å¸¸åˆ‡æ¢
- [ ] æœç´¢è¿›åº¦å®æ—¶æ›´æ–°
- [ ] traceæ•°æ®å¯è¯»æ€§å¥½

### **å®æ—¶æ•°æ®æ¨é€**
- [ ] WebSocketæ•°æ®æ¨é€åŠæ—¶
- [ ] è¿æ¥æ–­å¼€èƒ½è‡ªåŠ¨é‡è¿
- [ ] æ•°æ®æ ¼å¼æ­£ç¡®

---

**ä¸‹ä¸€æ­¥**: é€‰æ‹©ä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡å¼€å§‹å®æ–½ï¼Œå»ºè®®ä»**ä»»åŠ¡1.1: æ•°æ®ç»“æ„å®šä¹‰**å¼€å§‹ï¼