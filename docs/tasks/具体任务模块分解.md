# 前端搜索过程可视化 - 具体任务模块分解

基于当前项目代码结构，将实施计划分解为具体的可执行任务模块。

---

## 📋 任务模块总览

### **模块1: 数据结构定义** (优先级: 最高)
- 创建TypeScript接口定义
- 基于现有代码结构设计trace格式

### **模块2: SearchService增强** (优先级: 最高)
- 修改现有SearchService添加trace收集
- 实现调试模式开关

### **模块3: API端点扩展** (优先级: 高)
- 在现有routes.py中添加调试接口
- 实现WebSocket支持

### **模块4: 前端界面组件** (优先级: 高)
- 基于现有frontend/修改界面
- 创建搜索过程可视化组件

### **模块5: 实时数据推送** (优先级: 中)
- 实现WebSocket连接
- 前后端数据同步

---

## 🔧 任务模块详细分解

### **模块1: 数据结构定义**

#### 任务1.1: 创建TypeScript类型定义文件
**文件**: `src/types/debug_interfaces.py`

```python
# 创建Python数据模型
from typing import Dict, List, Optional, Any, Union
from pydantic import BaseModel
from datetime import datetime

class ModuleTrace(BaseModel):
    """模块执行trace数据"""
    module_name: str
    stage: str
    input_data: Any
    output_data: Any
    processing_time_ms: float
    success: bool
    confidence_score: Optional[float] = None
    debug_info: Dict[str, Any]
    metadata: Dict[str, Any]
    timestamp: datetime

class SearchPipelineTrace(BaseModel):
    """搜索管道完整trace"""
    request_id: str
    user_query: str
    total_duration_ms: float

    # 各阶段trace
    classification: Optional[ModuleTrace] = None
    extraction: Optional[ModuleTrace] = None
    routing: Optional[ModuleTrace] = None
    searches: Dict[str, ModuleTrace] = {}
    fusion: Optional[ModuleTrace] = None

    # 统计信息
    summary: Dict[str, Any]
```

**预计耗时**: 0.5天

#### 任务1.2: 创建前端TypeScript接口
**文件**: `frontend/types/search-debug.ts`

```typescript
// 对应Python模型的TypeScript接口
export interface ModuleTrace {
  module_name: string;
  stage: string;
  input_data: any;
  output_data: any;
  processing_time_ms: number;
  success: boolean;
  confidence_score?: number;
  debug_info: Record<string, any>;
  metadata: Record<string, any>;
  timestamp: string;
}

export interface SearchPipelineTrace {
  request_id: string;
  user_query: string;
  total_duration_ms: number;
  classification?: ModuleTrace;
  extraction?: ModuleTrace;
  routing?: ModuleTrace;
  searches: Record<string, ModuleTrace>;
  fusion?: ModuleTrace;
  summary: Record<string, any>;
}
```

**预计耗时**: 0.5天

---

### **模块2: SearchService增强**

#### 任务2.1: 修改现有SearchService类
**文件**: `src/services/search_service.py`

```python
# 在现有SearchService中添加trace收集功能

class SearchService:
    def __init__(self, repository: ILegalDocumentRepository, debug_mode: bool = False):
        self.repository = repository
        self.debug_mode = debug_mode
        self.current_trace: Optional[SearchPipelineTrace] = None

    async def search_documents_kg_enhanced_with_trace(self, query_text: str,
                                                    articles_count: int = 5,
                                                    cases_count: int = 5) -> Tuple[Dict[str, Any], Optional[ModuleTrace]]:
        """现有知识图谱搜索方法 + trace收集"""
        start_time = time.time()

        try:
            # 调用现有方法
            result = await self.search_documents_kg_enhanced(query_text, articles_count, cases_count)

            # 收集trace信息
            if self.debug_mode:
                trace = ModuleTrace(
                    module_name="knowledge_graph_search",
                    stage="search_execution",
                    input_data={
                        "query": query_text,
                        "articles_count": articles_count,
                        "cases_count": cases_count
                    },
                    output_data=result,
                    processing_time_ms=(time.time() - start_time) * 1000,
                    success=result.get('success', False),
                    debug_info={
                        "method_used": "kg_enhanced",
                        "fallback_triggered": not result.get('search_context', {}).get('kg_enhanced', False),
                        "knowledge_expansion": result.get('search_context', {}).get('knowledge_expansion', {})
                    },
                    metadata={
                        "timestamp": datetime.now().isoformat(),
                        "module_version": "1.0.0"
                    }
                )
                return result, trace

            return result, None

        except Exception as e:
            if self.debug_mode:
                trace = ModuleTrace(
                    module_name="knowledge_graph_search",
                    stage="search_execution",
                    input_data={"query": query_text},
                    output_data={},
                    processing_time_ms=(time.time() - start_time) * 1000,
                    success=False,
                    debug_info={
                        "error_message": str(e),
                        "fallback_triggered": True
                    },
                    metadata={"timestamp": datetime.now().isoformat()}
                )
                return self._create_error_response(str(e)), trace

            raise e
```

**预计耗时**: 1天

#### 任务2.2: 为其他搜索方法添加trace
**文件**: 继续修改 `src/services/search_service.py`

```python
# 为每个现有搜索方法添加trace版本
async def search_documents_mixed_with_trace(self, ...):
    """基础语义搜索 + trace"""
    # 类似实现...

async def search_documents_hybrid_with_trace(self, ...):
    """BM25混合搜索 + trace"""
    # 类似实现...

async def search_documents_enhanced_with_trace(self, ...):
    """LLM增强搜索 + trace"""
    # 类似实现...
```

**预计耗时**: 1天

#### 任务2.3: 创建统一的调试搜索方法
**文件**: 继续修改 `src/services/search_service.py`

```python
async def search_with_full_pipeline_trace(self, query_text: str,
                                        articles_count: int = 5,
                                        cases_count: int = 5) -> SearchPipelineTrace:
    """完整的5阶段搜索管道 + 完整trace"""
    request_id = str(uuid.uuid4())
    start_time = time.time()

    pipeline_trace = SearchPipelineTrace(
        request_id=request_id,
        user_query=query_text,
        total_duration_ms=0,
        searches={},
        summary={}
    )

    # 阶段1: LLM分类 (模拟实现)
    classification_result, classification_trace = await self._classify_query_with_trace(query_text)
    pipeline_trace.classification = classification_trace

    if classification_result.get('is_criminal_law', True):  # 刑法相关
        # 阶段2: 结构化提取
        extraction_result, extraction_trace = await self._extract_structured_info_with_trace(query_text)
        pipeline_trace.extraction = extraction_trace

        # 阶段3: 智能路由
        routing_result, routing_trace = await self._intelligent_routing_with_trace(extraction_result)
        pipeline_trace.routing = routing_trace

        # 阶段4: 并行搜索
        search_results = {}
        if 'kg_search' in routing_result.get('selected_paths', []):
            result, trace = await self.search_documents_kg_enhanced_with_trace(query_text, articles_count, cases_count)
            search_results['knowledge_graph'] = result
            pipeline_trace.searches['knowledge_graph'] = trace

        if 'enhanced_search' in routing_result.get('selected_paths', []):
            result, trace = await self.search_documents_enhanced_with_trace(query_text, articles_count, cases_count)
            search_results['llm_enhanced'] = result
            pipeline_trace.searches['llm_enhanced'] = trace

        # 阶段5: 融合
        fusion_result, fusion_trace = await self._fuse_results_with_trace(search_results)
        pipeline_trace.fusion = fusion_trace

    else:  # 非刑法问题
        # 直接AI回答模式
        ai_result, ai_trace = await self._general_ai_response_with_trace(query_text)
        pipeline_trace.searches['general_ai'] = ai_trace

    # 完成总体统计
    pipeline_trace.total_duration_ms = (time.time() - start_time) * 1000
    pipeline_trace.summary = self._generate_pipeline_summary(pipeline_trace)

    return pipeline_trace
```

**预计耗时**: 1.5天

---

### **模块3: API端点扩展**

#### 任务3.1: 修改现有routes.py添加调试接口
**文件**: `src/api/routes.py`

```python
# 在现有routes.py中添加调试相关的路由

@router.post("/search/debug")
async def debug_search(request: SearchRequest, search_service: SearchService = Depends(get_search_service)):
    """调试模式搜索 - 返回完整trace"""
    try:
        # 临时启用调试模式
        search_service.debug_mode = True

        pipeline_trace = await search_service.search_with_full_pipeline_trace(
            request.query,
            request.articles_count,
            request.cases_count
        )

        return {
            "success": True,
            "trace": pipeline_trace.dict(),
            "request_id": pipeline_trace.request_id
        }

    except Exception as e:
        logger.error(f"Debug search failed: {e}")
        return {"success": False, "error": str(e)}


@router.get("/debug/trace/{request_id}")
async def get_search_trace(request_id: str):
    """获取特定搜索的trace记录"""
    # 从Redis或数据库获取存储的trace
    pass

@router.get("/debug/modules/status")
async def get_modules_status():
    """获取所有搜索模块状态"""
    return {
        "modules": {
            "knowledge_graph": {"status": "error", "reason": "未初始化"},
            "llm_enhanced": {"status": "error", "reason": "代码bug"},
            "bm25_hybrid": {"status": "warning", "reason": "依赖BM25索引"},
            "basic_semantic": {"status": "ok", "reason": "完全可用"}
        }
    }
```

**预计耗时**: 1天

#### 任务3.2: 实现WebSocket支持
**文件**: `src/api/websocket.py` (新建文件)

```python
# 创建WebSocket支持实时数据推送

from fastapi import WebSocket
import json
import asyncio

class DebugWebSocketManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast_trace_update(self, trace_data: dict):
        """广播trace更新到所有连接的客户端"""
        for connection in self.active_connections:
            await connection.send_text(json.dumps(trace_data))

manager = DebugWebSocketManager()

@router.websocket("/ws/debug")
async def debug_websocket(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            # 保持连接
            await websocket.receive_text()
    except:
        manager.disconnect(websocket)
```

**预计耗时**: 0.5天

---

### **模块4: 前端界面组件**

#### 任务4.1: 修改现有前端界面添加调试面板
**文件**: `frontend/index.html`

```html
<!-- 在现有界面基础上添加调试面板 -->

<!-- 添加调试模式切换 -->
<div class="debug-controls" style="margin-bottom: 20px;">
    <label>
        <input type="checkbox" id="debugMode" onchange="toggleDebugMode()">
        调试模式 - 显示搜索过程
    </label>
</div>

<!-- 搜索进度展示面板 -->
<div id="searchProgress" class="search-progress" style="display: none;">
    <h3>搜索过程实时展示</h3>

    <div class="pipeline-stages">
        <div class="stage" id="stage-classification">
            <div class="stage-icon">🤖</div>
            <div class="stage-name">问题分类</div>
            <div class="stage-status">等待中...</div>
            <div class="stage-time"></div>
        </div>

        <div class="stage" id="stage-extraction">
            <div class="stage-icon">🔍</div>
            <div class="stage-name">信息提取</div>
            <div class="stage-status">等待中...</div>
            <div class="stage-time"></div>
        </div>

        <div class="stage" id="stage-search">
            <div class="stage-icon">📚</div>
            <div class="stage-name">智能搜索</div>
            <div class="stage-status">等待中...</div>
            <div class="stage-time"></div>
        </div>

        <div class="stage" id="stage-fusion">
            <div class="stage-icon">⚡</div>
            <div class="stage-name">结果融合</div>
            <div class="stage-status">等待中...</div>
            <div class="stage-time"></div>
        </div>
    </div>
</div>

<!-- 详细数据查看面板 -->
<div id="debugDetails" class="debug-details" style="display: none;">
    <h3>详细调试信息</h3>
    <div class="trace-data">
        <pre id="traceJson"></pre>
    </div>
</div>
```

**预计耗时**: 1天

#### 任务4.2: 添加JavaScript处理逻辑
**文件**: `frontend/js/debug.js` (新建文件)

```javascript
// 调试模式的JavaScript处理逻辑

class SearchDebugger {
    constructor() {
        this.debugMode = false;
        this.currentTrace = null;
        this.ws = null;
    }

    toggleDebugMode() {
        this.debugMode = document.getElementById('debugMode').checked;

        if (this.debugMode) {
            document.getElementById('searchProgress').style.display = 'block';
            document.getElementById('debugDetails').style.display = 'block';
            this.connectWebSocket();
        } else {
            document.getElementById('searchProgress').style.display = 'none';
            document.getElementById('debugDetails').style.display = 'none';
            if (this.ws) this.ws.close();
        }
    }

    connectWebSocket() {
        this.ws = new WebSocket('ws://localhost:5006/ws/debug');

        this.ws.onmessage = (event) => {
            const traceData = JSON.parse(event.data);
            this.updateProgress(traceData);
        };
    }

    async performDebugSearch(query) {
        if (!this.debugMode) {
            return await this.performNormalSearch(query);
        }

        this.resetProgress();

        const response = await fetch('/api/search/debug', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                query: query,
                articles_count: 5,
                cases_count: 5
            })
        });

        const result = await response.json();
        if (result.success) {
            this.currentTrace = result.trace;
            this.displayTraceData(result.trace);
            this.updateFinalProgress(result.trace);
        }

        return result;
    }

    updateProgress(traceData) {
        if (traceData.module_name) {
            const stageId = this.mapModuleToStage(traceData.module_name);
            const stage = document.getElementById(stageId);

            if (stage) {
                stage.querySelector('.stage-status').textContent =
                    traceData.success ? '完成' : '失败';
                stage.querySelector('.stage-time').textContent =
                    `${traceData.processing_time_ms.toFixed(0)}ms`;
                stage.className = 'stage ' + (traceData.success ? 'success' : 'error');
            }
        }
    }

    mapModuleToStage(moduleName) {
        const mapping = {
            'llm_classifier': 'stage-classification',
            'structured_extractor': 'stage-extraction',
            'knowledge_graph_search': 'stage-search',
            'llm_enhanced_search': 'stage-search',
            'result_fusion': 'stage-fusion'
        };
        return mapping[moduleName] || 'stage-search';
    }

    displayTraceData(trace) {
        document.getElementById('traceJson').textContent =
            JSON.stringify(trace, null, 2);
    }
}

// 全局实例
const debugger = new SearchDebugger();

// 修改现有的搜索函数
async function performSearch() {
    const query = document.getElementById('searchInput').value;
    if (!query.trim()) return;

    const result = await debugger.performDebugSearch(query);

    // 显示搜索结果
    displaySearchResults(result);
}

function toggleDebugMode() {
    debugger.toggleDebugMode();
}
```

**预计耗时**: 1.5天

---

### **模块5: 实时数据推送**

#### 任务5.1: 集成WebSocket到搜索流程
**文件**: 修改 `src/services/search_service.py`

```python
# 在搜索过程中推送实时更新

class SearchService:
    def __init__(self, repository, debug_mode=False, websocket_manager=None):
        self.repository = repository
        self.debug_mode = debug_mode
        self.websocket_manager = websocket_manager

    async def _notify_trace_update(self, trace: ModuleTrace):
        """推送trace更新到前端"""
        if self.websocket_manager and self.debug_mode:
            await self.websocket_manager.broadcast_trace_update(trace.dict())

    async def search_documents_kg_enhanced_with_trace(self, ...):
        # 现有逻辑...

        # 添加实时推送
        if trace:
            await self._notify_trace_update(trace)

        return result, trace
```

**预计耗时**: 0.5天

#### 任务5.2: 前端WebSocket连接优化
**文件**: 修改 `frontend/js/debug.js`

```javascript
// 优化WebSocket连接和错误处理

connectWebSocket() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        return;
    }

    this.ws = new WebSocket('ws://localhost:5006/ws/debug');

    this.ws.onopen = () => {
        console.log('调试WebSocket连接已建立');
    };

    this.ws.onmessage = (event) => {
        try {
            const traceData = JSON.parse(event.data);
            this.updateProgress(traceData);
        } catch (e) {
            console.error('解析trace数据失败:', e);
        }
    };

    this.ws.onerror = (error) => {
        console.error('WebSocket错误:', error);
    };

    this.ws.onclose = () => {
        console.log('WebSocket连接已关闭');
        // 如果是意外关闭，尝试重连
        if (this.debugMode) {
            setTimeout(() => this.connectWebSocket(), 3000);
        }
    };
}
```

**预计耗时**: 0.5天

---

## 📅 任务执行顺序

### **第一周**
1. **任务1.1 + 1.2**: 数据结构定义 (1天)
2. **任务2.1**: SearchService基础增强 (1天)
3. **任务2.2**: 其他搜索方法trace (1天)
4. **任务2.3**: 统一调试搜索方法 (1.5天)
5. **任务3.1**: API端点扩展 (0.5天)

### **第二周**
6. **任务3.2**: WebSocket支持 (0.5天)
7. **任务4.1**: 前端界面组件 (1天)
8. **任务4.2**: JavaScript处理逻辑 (1.5天)
9. **任务5.1**: WebSocket集成 (0.5天)
10. **任务5.2**: 前端连接优化 (0.5天)

**总计**: 9个工作日

---

## 🎯 每个任务的验收标准

### **数据结构定义**
- [ ] Python ModuleTrace类定义完整
- [ ] TypeScript接口与Python模型一致
- [ ] 所有必需字段都有明确类型

### **SearchService增强**
- [ ] 现有搜索方法不受影响
- [ ] 调试模式可正常开启/关闭
- [ ] trace数据格式正确且完整

### **API端点扩展**
- [ ] `/api/search/debug`接口正常工作
- [ ] WebSocket连接稳定
- [ ] 错误处理完善

### **前端界面组件**
- [ ] 调试面板可正常切换
- [ ] 搜索进度实时更新
- [ ] trace数据可读性好

### **实时数据推送**
- [ ] WebSocket数据推送及时
- [ ] 连接断开能自动重连
- [ ] 数据格式正确

---

**下一步**: 选择优先级最高的任务开始实施，建议从**任务1.1: 数据结构定义**开始！